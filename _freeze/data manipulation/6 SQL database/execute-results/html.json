{
  "hash": "4ffeabe23b7c7b136e52547b99ce2ea4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with SQL Databases in R\"\nauthor: \"Tony Duan\"\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: false\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n---\n\nThis document explains how to connect to and interact with SQL databases from within R. We will cover writing raw SQL queries, using the `tidyverse`-friendly `dbplyr` package, and other best practices.\n\n![](images/1594917913096.png){width=\"600\"}\n\n# 1. Connecting to a Database\n\nThe `DBI` package provides a universal, consistent interface for connecting to any database. Specific packages like `RSQLite`, `RPostgres`, or `odbc` provide the actual drivers to connect to different database systems.\n\nFor these examples, we will use `RSQLite`, which creates a lightweight, file-based SQL database.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(tidyverse)\n```\n:::\n\n## Create and Populate a Database\n\nFirst, we connect to a database file (it will be created if it doesn't exist). Then, we write the `mtcars` and `iris` R data frames into the database as new tables.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add car names as a column in mtcars\nmtcars_df =cbind(car_name = rownames(mtcars), mtcars)\n\n# Create a connection to an SQLite database file\ncon <- dbConnect(RSQLite::SQLite(), \"data/my_sql_database.db\")\n\n# Write the R data frames to the database\n# `overwrite = TRUE` will replace the table if it already exists\ndbWriteTable(con, \"mtcars\", mtcars_df, overwrite = TRUE)\ndbWriteTable(con, \"iris\", iris, overwrite = TRUE)\n```\n:::\n\nWe can list the tables to confirm they were created.\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"car_parts\" \"iris\"      \"mtcars\"    \"part_info\"\n```\n\n\n:::\n:::\n\n# 2. Method 1: Writing Raw SQL Queries\n\nThe `dbGetQuery()` function sends a SQL statement to the database and returns the result as a data frame.\n\n## SELECT Statement\n\nSelect all columns from the `mtcars` table, limiting the result to the first 3 rows.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_select <- \"SELECT * FROM mtcars LIMIT 3\"\ndbGetQuery(con, sql_select)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       car_name  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1     Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2 Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3    Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n```\n\n\n:::\n:::\n\n## Column Aliasing and Creation\n\nUse `AS` to rename a column in the output. You can also create new columns based on calculations.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_create_col <- \"SELECT mpg, mpg + 1 AS mpg_plus_one FROM mtcars\"\nhead(dbGetQuery(con, sql_create_col))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   mpg mpg_plus_one\n1 21.0         22.0\n2 21.0         22.0\n3 22.8         23.8\n4 21.4         22.4\n5 18.7         19.7\n6 18.1         19.1\n```\n\n\n:::\n:::\n\n## Filtering with WHERE\n\nThe `WHERE` clause filters rows based on a condition.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_filter <- \"SELECT * FROM mtcars WHERE hp > 200 AND cyl = 8\"\nhead(dbGetQuery(con, sql_filter))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             car_name  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1          Duster 360 14.3   8  360 245 3.21 3.570 15.84  0  0    3    4\n2  Cadillac Fleetwood 10.4   8  472 205 2.93 5.250 17.98  0  0    3    4\n3 Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4\n4   Chrysler Imperial 14.7   8  440 230 3.23 5.345 17.42  0  0    3    4\n5          Camaro Z28 13.3   8  350 245 3.73 3.840 15.41  0  0    3    4\n6      Ford Pantera L 15.8   8  351 264 4.22 3.170 14.50  0  1    5    4\n```\n\n\n:::\n:::\n\n## Aggregation with GROUP BY\n\n`GROUP BY` collapses multiple rows into a single summary row. It's used with aggregate functions like `AVG()`, `COUNT()`, `MIN()`, and `MAX()`.\n\nThis query calculates the average horsepower and row count for each cylinder group.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_groupby <- \"SELECT cyl, AVG(hp) AS avg_hp, COUNT(*) AS num_cars FROM mtcars GROUP BY cyl\"\ndbGetQuery(con, sql_groupby)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cyl    avg_hp num_cars\n1   4  82.63636       11\n2   6 122.28571        7\n3   8 209.21429       14\n```\n\n\n:::\n:::\n\n## Sorting with ORDER BY\n\n`ORDER BY` sorts the result set in ascending (`ASC`) or descending (`DESC`) order.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_orderby <- \"SELECT car_name, mpg, hp FROM mtcars ORDER BY hp DESC LIMIT 5\"\ndbGetQuery(con, sql_orderby)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name  mpg  hp\n1     Maserati Bora 15.0 335\n2    Ford Pantera L 15.8 264\n3        Duster 360 14.3 245\n4        Camaro Z28 13.3 245\n5 Chrysler Imperial 14.7 230\n```\n\n\n:::\n:::\n\n## Joins\n\nThis example creates two tables, `car_parts` and `part_info`, to demonstrate joins.\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con, \"car_parts\", data.frame(car_name = c(\"Mazda RX4\", \"Datsun 710\", \"Hornet 4 Drive\"), part_id = c(1, 2, 3)), overwrite = TRUE)\ndbWriteTable(con, \"part_info\", data.frame(part_id = c(1, 2, 4), part_name = c(\"Engine\", \"Tire\", \"Brake\")), overwrite = TRUE)\n```\n:::\n\n### INNER JOIN\n\nReturns only the rows where the join key (`part_id`) exists in both tables.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_inner_join <- \"\nSELECT cp.car_name, pi.part_name\nFROM car_parts cp\nINNER JOIN part_info pi ON cp.part_id = pi.part_id\"\ndbGetQuery(con, sql_inner_join)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    car_name part_name\n1  Mazda RX4    Engine\n2 Datsun 710      Tire\n```\n\n\n:::\n:::\n\n### LEFT JOIN\n\nReturns all rows from the left table (`car_parts`) and the matched rows from the right table (`part_info`).\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_left_join <- \"\nSELECT cp.car_name, pi.part_name\nFROM car_parts cp\nLEFT JOIN part_info pi ON cp.part_id = pi.part_id\"\ndbGetQuery(con, sql_left_join)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        car_name part_name\n1      Mazda RX4    Engine\n2     Datsun 710      Tire\n3 Hornet 4 Drive      <NA>\n```\n\n\n:::\n:::\n\n## String and Date Functions\n\nSQL has functions for manipulating strings and dates. The exact syntax can vary by database. In SQLite, you can use `UPPER()` and `strftime()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_string_date <- \"SELECT car_name, UPPER(car_name) AS upper_name, '2023-10-27' AS today from car_parts\"\nhead(dbGetQuery(con, sql_string_date))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        car_name     upper_name      today\n1      Mazda RX4      MAZDA RX4 2023-10-27\n2     Datsun 710     DATSUN 710 2023-10-27\n3 Hornet 4 Drive HORNET 4 DRIVE 2023-10-27\n```\n\n\n:::\n:::\n\n## Modifying Data\n\n### UPDATE Table\n\n`UPDATE` modifies existing records in a table.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: dbExecute is used for statements that don't return data\ndbExecute(con, \"UPDATE mtcars SET hp = 120 WHERE car_name = 'Mazda RX4'\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\ndbGetQuery(con, \"SELECT car_name, hp FROM mtcars WHERE car_name = 'Mazda RX4'\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   car_name  hp\n1 Mazda RX4 120\n```\n\n\n:::\n:::\n\n### CREATE and DROP Table\n\n`CREATE TABLE` builds a new table, and `DROP TABLE` deletes it.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_create <- \"CREATE TABLE mtcars_copy AS SELECT * FROM mtcars\"\ndbExecute(con, sql_create)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"car_parts\"   \"iris\"        \"mtcars\"      \"mtcars_copy\" \"part_info\"  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_drop <- \"DROP TABLE mtcars_copy\"\ndbExecute(con, sql_drop)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"car_parts\" \"iris\"      \"mtcars\"    \"part_info\"\n```\n\n\n:::\n:::\n\n# 3. Method 2: Using `dbplyr`\n\n`dbplyr` is a `tidyverse` backend for databases. It allows you to write familiar `dplyr` code, which `dbplyr` translates into SQL for you. This is the recommended modern approach as it is easier to write and less prone to SQL injection errors.\n\nFirst, we create a connection to the `mtcars` table in the database.\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_db <- tbl(con, \"mtcars\")\n```\n:::\n\nNow, we can use `dplyr` verbs on this object. The code is not run in R; it is translated to SQL and sent to the database.\n\n::: {.cell}\n\n```{.r .cell-code}\nquery <- mtcars_db %>%\n  select(car_name, mpg, hp, cyl) %>%\n  filter(hp > 150) %>%\n  group_by(cyl) %>%\n  summarise(avg_mpg = mean(mpg, na.rm = TRUE)) %>%\n  arrange(desc(avg_mpg))\n```\n:::\n\nWe can use `show_query()` to see the SQL that `dbplyr` generated.\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_query(query)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `cyl`, AVG(`mpg`) AS `avg_mpg`\nFROM (\n  SELECT `car_name`, `mpg`, `hp`, `cyl`\n  FROM `mtcars`\n  WHERE (`hp` > 150.0)\n) AS `q01`\nGROUP BY `cyl`\nORDER BY `avg_mpg` DESC\n```\n\n\n:::\n:::\n\nTo execute the query and pull the results back into an R data frame, we use `collect()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- collect(query)\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n    cyl avg_mpg\n  <dbl>   <dbl>\n1     6    19.7\n2     8    15.1\n```\n\n\n:::\n:::\n\n# 4. Best Practice: Parameterized Queries\n\nTo prevent SQL injection attacks, you should not use `paste()` to insert values into a SQL query. Instead, use parameterized queries with `?` as a placeholder. `DBI` will safely insert the values for you.\n\n::: {.cell}\n\n```{.r .cell-code}\nhp_threshold <- 150\nsql_safe <- \"SELECT car_name, hp FROM mtcars WHERE hp > ?\"\n\n# dbGetQuery can take a `params` list\ndbGetQuery(con, sql_safe, params = list(hp_threshold)) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            car_name  hp\n1  Hornet Sportabout 175\n2         Duster 360 245\n3         Merc 450SE 180\n4         Merc 450SL 180\n5        Merc 450SLC 180\n6 Cadillac Fleetwood 205\n```\n\n\n:::\n:::\n\n# 5. Method 3: Using `sqldf` on Local Data Frames\n\nThe `sqldf` package allows you to run SQL queries on local R data frames, not on an external database. This can be useful for users who are more comfortable with SQL than with `dplyr` syntax for data manipulation.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sqldf)\n\n# Note the use of the R data frame `mtcars_df`\nsqldf(\"SELECT car_name, mpg FROM mtcars_df WHERE cyl = 8 LIMIT 5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name  mpg\n1 Hornet Sportabout 18.7\n2        Duster 360 14.3\n3        Merc 450SE 16.4\n4        Merc 450SL 17.3\n5       Merc 450SLC 15.2\n```\n\n\n:::\n:::\n\n# 6. Disconnecting from the Database\n\nIt is very important to close the database connection when you are finished to release resources.\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(con)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}