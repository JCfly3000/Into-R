{
  "hash": "7bb1f71eacd0a70c41b788766d60f863",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with SQL Databases in R\"\nauthor: \"Tony Duan\"\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: false\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n---\n\nThis document provides a comprehensive guide on how to connect to and interact with SQL databases directly from R. We will explore three primary methods: writing raw SQL queries, using the modern `dbplyr` package for a `tidyverse`-like experience, and using `sqldf` to query local data frames with SQL syntax.\n\n![](images/1594917913096.png){width=\"600\"}\n\n# 1. Why Use a Database with R?\n\nWhile R is excellent at in-memory data manipulation, connecting to a database is essential when:\n\n-   **Data size is too large:** The dataset is too big to fit into your computer's RAM. Databases are optimized for storing and querying massive datasets efficiently.\n-   **Data is centralized:** The data is stored in a central location, accessed by multiple users or applications, ensuring data consistency and integrity.\n-   **Production environments:** You need to query or write to a production database system as part of an analytical workflow. The database handles tasks like security, backups, and concurrent access.\n\n# 2. Connecting to a Database\n\nThe `DBI` (Database Interface) package provides a universal, consistent interface for connecting to any database. Specific driver packages like `RSQLite`, `RPostgres`, or `odbc` handle the connection to different database systems.\n\nFor these examples, we will use `RSQLite`, which creates a lightweight, file-based SQL database that is perfect for learning and demonstration.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the necessary libraries\nlibrary(DBI)\nlibrary(RSQLite)\nlibrary(tidyverse)\n```\n:::\n\n## Create and Populate a Database\n\nFirst, we establish a connection to a database file. If the file doesn't exist, `dbConnect()` will create it. Then, we'll copy the `mtcars` and `iris` R data frames into the database, creating new tables.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add car names as a column in mtcars, as they are originally row names\nmtcars_df <- mtcars %>% \n  rownames_to_column(var = \"car_name\")\n\n# Create a connection to an SQLite database file in the 'data' subdirectory\ncon <- dbConnect(RSQLite::SQLite(), \"data/my_sql_database.db\")\n\n# Write the R data frames to the database\n# `overwrite = TRUE` will replace the table if it already exists\ndbWriteTable(con, \"mtcars\", mtcars_df, overwrite = TRUE)\ndbWriteTable(con, \"iris\", iris, overwrite = TRUE)\n```\n:::\n\nWe can list the tables to confirm they were successfully created.\n\n::: {.cell}\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"car_parts\" \"iris\"      \"mtcars\"    \"part_info\"\n```\n\n\n:::\n:::\n\n# 3. Method 1: Writing Raw SQL Queries\n\nThis approach involves sending SQL statements as text strings to the database. The `dbGetQuery()` function executes the query and returns the result as a data frame in R.\n\n## SELECT Statement\n\nSelect all columns (`*`) from the `mtcars` table. `LIMIT` restricts the output to the first 3 rows.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_select <- \"SELECT * FROM mtcars LIMIT 3\"\ndbGetQuery(con, sql_select)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       car_name  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1     Mazda RX4 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2 Mazda RX4 Wag 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3    Datsun 710 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n```\n\n\n:::\n:::\n\n## Column Aliasing and Creation\n\nUse `AS` to rename a column in the query's output. You can also create new columns based on calculations on existing ones.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_create_col <- \"SELECT mpg, mpg * 0.425 AS kpl FROM mtcars\" # Convert MPG to KPL\nhead(dbGetQuery(con, sql_create_col))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   mpg    kpl\n1 21.0 8.9250\n2 21.0 8.9250\n3 22.8 9.6900\n4 21.4 9.0950\n5 18.7 7.9475\n6 18.1 7.6925\n```\n\n\n:::\n:::\n\n## Filtering with WHERE\n\nThe `WHERE` clause filters rows based on one or more conditions. `AND` requires both conditions to be true.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_filter <- \"SELECT * FROM mtcars WHERE hp > 200 AND cyl = 8\"\nhead(dbGetQuery(con, sql_filter))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             car_name  mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1          Duster 360 14.3   8  360 245 3.21 3.570 15.84  0  0    3    4\n2  Cadillac Fleetwood 10.4   8  472 205 2.93 5.250 17.98  0  0    3    4\n3 Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4\n4   Chrysler Imperial 14.7   8  440 230 3.23 5.345 17.42  0  0    3    4\n5          Camaro Z28 13.3   8  350 245 3.73 3.840 15.41  0  0    3    4\n6      Ford Pantera L 15.8   8  351 264 4.22 3.170 14.50  0  1    5    4\n```\n\n\n:::\n:::\n\n## Aggregation with GROUP BY\n\n`GROUP BY` is a powerful tool for summarizing data. It collapses multiple rows into a single summary row based on a grouping variable. It is almost always used with aggregate functions like `AVG()` (average), `COUNT()` (count), `MIN()` (minimum), and `MAX()` (maximum).\n\nThis query calculates the average horsepower and the number of cars for each cylinder group.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_groupby <- \"SELECT cyl, AVG(hp) AS avg_hp, COUNT(*) AS num_cars FROM mtcars GROUP BY cyl\"\ndbGetQuery(con, sql_groupby)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  cyl    avg_hp num_cars\n1   4  82.63636       11\n2   6 122.28571        7\n3   8 209.21429       14\n```\n\n\n:::\n:::\n\n## Sorting with ORDER BY\n\n`ORDER BY` sorts the result set. The default is ascending order (`ASC`), but you can specify `DESC` for descending order.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_orderby <- \"SELECT car_name, mpg, hp FROM mtcars ORDER BY hp DESC LIMIT 5\"\ndbGetQuery(con, sql_orderby)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name  mpg  hp\n1     Maserati Bora 15.0 335\n2    Ford Pantera L 15.8 264\n3        Duster 360 14.3 245\n4        Camaro Z28 13.3 245\n5 Chrysler Imperial 14.7 230\n```\n\n\n:::\n:::\n\n## Joins\n\nJoins are used to combine rows from two or more tables based on a related column. We'll create two new tables to demonstrate.\n\n::: {.cell}\n\n```{.r .cell-code}\ndbWriteTable(con, \"car_parts\", data.frame(car_name = c(\"Mazda RX4\", \"Datsun 710\", \"Hornet 4 Drive\"), part_id = c(1, 2, 3)), overwrite = TRUE)\ndbWriteTable(con, \"part_info\", data.frame(part_id = c(1, 2, 4), part_name = c(\"Engine\", \"Tire\", \"Brake\")), overwrite = TRUE)\n```\n:::\n\n### INNER JOIN\n\nReturns only the rows where the join key (`part_id`) exists in **both** tables.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_inner_join <- \"\nSELECT cp.car_name, pi.part_name\nFROM car_parts cp\nINNER JOIN part_info pi ON cp.part_id = pi.part_id\"\ndbGetQuery(con, sql_inner_join)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    car_name part_name\n1  Mazda RX4    Engine\n2 Datsun 710      Tire\n```\n\n\n:::\n:::\n\n### LEFT JOIN\n\nReturns **all** rows from the left table (`car_parts`) and any matched rows from the right table (`part_info`). If there is no match, the columns from the right table will be `NA`.\n\n::: {.cell}\n\n```{.r .cell-code}\nsql_left_join <- \"\nSELECT cp.car_name, pi.part_name\nFROM car_parts cp\nLEFT JOIN part_info pi ON cp.part_id = pi.part_id\"\ndbGetQuery(con, sql_left_join)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        car_name part_name\n1      Mazda RX4    Engine\n2     Datsun 710      Tire\n3 Hornet 4 Drive      <NA>\n```\n\n\n:::\n:::\n\n## Modifying Data\n\nFor SQL commands that modify data but do not return a result set (like `UPDATE`, `CREATE`, `DROP`), use the `dbExecute()` function.\n\n### UPDATE Table\n\n`UPDATE` modifies existing records in a table.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the horsepower to 120 for the 'Mazda RX4'\ndbExecute(con, \"UPDATE mtcars SET hp = 120 WHERE car_name = 'Mazda RX4'\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Verify the change\ndbGetQuery(con, \"SELECT car_name, hp FROM mtcars WHERE car_name = 'Mazda RX4'\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   car_name  hp\n1 Mazda RX4 120\n```\n\n\n:::\n:::\n\n### CREATE and DROP Table\n\n`CREATE TABLE` builds a new table, and `DROP TABLE` permanently deletes one.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a copy of the mtcars table\nsql_create <- \"CREATE TABLE mtcars_copy AS SELECT * FROM mtcars\"\ndbExecute(con, sql_create)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"car_parts\"   \"iris\"        \"mtcars\"      \"mtcars_copy\" \"part_info\"  \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Drop the copy\nsql_drop <- \"DROP TABLE mtcars_copy\"\ndbExecute(con, sql_drop)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\ndbListTables(con)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"car_parts\" \"iris\"      \"mtcars\"    \"part_info\"\n```\n\n\n:::\n:::\n\n# 4. Method 2: Using `dbplyr` (Recommended)\n\n`dbplyr` is a `tidyverse` backend for databases. It allows you to write familiar `dplyr` code, which `dbplyr` translates into SQL for you. This is the **recommended modern approach** because it is:\n\n-   **Easier to write and read:** No need to remember the specific SQL dialect of your database.\n-   **Less error-prone:** Avoids syntax errors from manually writing SQL strings.\n-   **More secure:** Protects against SQL injection attacks automatically.\n-   **Lazy evaluation:** `dbplyr` only sends the query to the database when you explicitly ask for the results, which can save a lot of computation.\n\nFirst, we create a reference to the `mtcars` table in the database. This object is a pointer to the remote table; the data is not pulled into R yet.\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars_db <- tbl(con, \"mtcars\")\n```\n:::\n\nNow, we can use `dplyr` verbs on this `mtcars_db` object. The R code is not executed in R; it is translated to SQL and sent to the database for execution.\n\n::: {.cell}\n\n```{.r .cell-code}\nquery <- mtcars_db %>%\n  select(car_name, mpg, hp, cyl) %>%\n  filter(hp > 150) %>%\n  group_by(cyl) %>%\n  summarise(avg_mpg = mean(mpg, na.rm = TRUE), .groups = 'drop') %>%\n  arrange(desc(avg_mpg))\n```\n:::\n\nWe can use `show_query()` to inspect the SQL that `dbplyr` generated. This is a great way to learn SQL!\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_query(query)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `cyl`, AVG(`mpg`) AS `avg_mpg`\nFROM (\n  SELECT `car_name`, `mpg`, `hp`, `cyl`\n  FROM `mtcars`\n  WHERE (`hp` > 150.0)\n) AS `q01`\nGROUP BY `cyl`\nORDER BY `avg_mpg` DESC\n```\n\n\n:::\n:::\n\nTo execute the query and pull the results back into a standard R data frame, we use `collect()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- collect(query)\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n    cyl avg_mpg\n  <dbl>   <dbl>\n1     6    19.7\n2     8    15.1\n```\n\n\n:::\n:::\n\n# 5. Best Practice: Parameterized Queries\n\nWhen you must write raw SQL, it is critical to avoid using functions like `paste()` or `glue()` to insert values directly into a query string. This practice makes you vulnerable to **SQL injection**, a serious security risk.\n\nThe correct and safe method is to use **parameterized queries**. You use a placeholder (`?`) in the SQL string and provide the values in a separate list.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the R variable to be used in the query\nhp_threshold <- 150\n\n# Write the SQL with a placeholder (?)\nsql_safe <- \"SELECT car_name, hp FROM mtcars WHERE hp > ?\"\n\n# Provide the variable in the `params` list. DBI handles the safe substitution.\ndbGetQuery(con, sql_safe, params = list(hp_threshold)) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            car_name  hp\n1  Hornet Sportabout 175\n2         Duster 360 245\n3         Merc 450SE 180\n4         Merc 450SL 180\n5        Merc 450SLC 180\n6 Cadillac Fleetwood 205\n```\n\n\n:::\n:::\n\n# 6. Method 3: Using `sqldf` on Local Data Frames\n\nThe `sqldf` package offers a unique functionality: it allows you to run SQL queries on **local R data frames**, not on an external database. This can be a convenient tool for users who are more comfortable with SQL syntax than with `dplyr` for data manipulation tasks.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sqldf)\n\n# Note the use of the local R data frame `mtcars_df`, not a database connection\nsqldf(\"SELECT car_name, mpg FROM mtcars_df WHERE cyl = 8 LIMIT 5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           car_name  mpg\n1 Hornet Sportabout 18.7\n2        Duster 360 14.3\n3        Merc 450SE 16.4\n4        Merc 450SL 17.3\n5       Merc 450SLC 15.2\n```\n\n\n:::\n:::\n\n# 7. Database Transactions\n\nA transaction is a sequence of operations performed as a single logical unit of work. All the operations in a transaction must succeed; if any of them fail, the entire transaction is rolled back, and the database is left unchanged. This ensures data integrity.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start a transaction\ndbBegin(con)\n\n# Try to execute two statements\n# The first will succeed, the second will fail because the table doesn't exist\ndbExecute(con, \"UPDATE mtcars SET hp = 999 WHERE car_name = 'Mazda RX4'\")\ndbExecute(con, \"UPDATE non_existent_table SET col = 1\")\n\n# If there was an error, dbCommit will fail and you should rollback\n# In a real script, you would wrap this in tryCatch()\n# For this example, we manually rollback\ndbRollback(con)\n\n# Check the value - it should NOT be 999 because the transaction was rolled back\ndbGetQuery(con, \"SELECT hp FROM mtcars WHERE car_name = 'Mazda RX4'\")\n```\n:::\n\n# 8. Disconnecting from the Database\n\nIt is very important to close the database connection when you are finished. This releases resources on both your machine and the database server.\n\n::: {.cell}\n\n```{.r .cell-code}\ndbDisconnect(con)\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}