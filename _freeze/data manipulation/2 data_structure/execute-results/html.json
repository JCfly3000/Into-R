{
  "hash": "471635183ed3e2ece9f56deba1189f04",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Structures in R\"\nexecute:\n  warning: false\n  error: false\nformat:\n  html:\n    toc: true\n    toc-location: right\n    code-fold: show\n    code-tools: true\n    number-sections: false\n    code-block-bg: true\n    code-block-border-left: \"#31BAE9\"\n---\n\nThis document provides a detailed overview of the fundamental data structures in R. Understanding these structures is essential for effective programming and data analysis in R. Each structure has its own strengths and is suited for different types of tasks.\n\n![](images/download.jpg){width=\"600\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n# 1. Vectors\n\nA vector is a one-dimensional, ordered collection of elements. A key characteristic of vectors is that all elements must be of the same data type (**homogeneous**). They are the simplest and most common data structure in R.\n\n### Creating Vectors\n\nVectors are typically created with the `c()` (combine) function.\n\n::: {.cell}\n\n```{.r .cell-code}\n# A numeric vector\nnumeric_vector <- c(10.5, 2.3, 15.0, 4.8)\nnumeric_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.5  2.3 15.0  4.8\n```\n\n\n:::\n\n```{.r .cell-code}\n# A character vector\ncharacter_vector <- c(\"apple\", \"banana\", \"cherry\")\ncharacter_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"  \"banana\" \"cherry\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# A logical vector\nlogical_vector <- c(TRUE, FALSE, TRUE, TRUE)\nlogical_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n\n#### Sequence Vector\n\nThe `seq()` function generates a sequence of numbers.\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 2, to = 14, by = 2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10 12 14\n```\n\n\n:::\n:::\n\n#### Replicated Vector\n\nThe `rep()` function repeats a value a specified number of times.\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(x = 1.5, times = 4)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5 1.5 1.5 1.5\n```\n\n\n:::\n:::\n\n#### Random Vector\n\nThe `sample()` function takes a random sample from a set of elements. `replace = FALSE` means each element can only be chosen once.\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:10, 5, replace = FALSE) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  5 10  7  4\n```\n\n\n:::\n:::\n\nWith `replace = TRUE`, elements can be chosen multiple times.\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(1:10, 5, replace = TRUE) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10  7  4  8  4\n```\n\n\n:::\n:::\n\n`runif()` generates random numbers from a uniform distribution.\n\n::: {.cell}\n\n```{.r .cell-code}\nrunif(1, min = 0, max = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7881073\n```\n\n\n:::\n:::\n\n`rnorm()` generates random numbers from a normal distribution.\n\n::: {.cell}\n\n```{.r .cell-code}\nsn1 <- rnorm(4, mean = 0, sd = 1) # Standard normal distribution\nsn1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.4745783 -1.9213412  0.7861794  1.6874680\n```\n\n\n:::\n:::\n\n#### Unique Vector\n\nThe `unique()` function removes duplicate elements from a vector.\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 = c(1, 1, 2, 2, 5, 6)\nv1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 2 2 5 6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(v1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 5 6\n```\n\n\n:::\n:::\n\n\n\n### Type Coercion\n\nIf you try to mix types, R will **coerce** the elements to the most flexible type in a specific hierarchy: `logical` -> `integer` -> `numeric` -> `character`. For example, mixing numbers and characters will result in a character vector because character is the most flexible type.\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_vector <- c(1, \"apple\", 3.5, TRUE)\nclass(mixed_vector) # All elements are now characters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmixed_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"     \"apple\" \"3.5\"   \"TRUE\" \n```\n\n\n:::\n:::\n\n### Vector Operations\n\nMathematical and logical operations on vectors are performed element-wise. This is a powerful feature called vectorization, which is much faster than writing a loop.\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, 3)\nb <- c(10, 20, 30)\n\na + b # Element-wise addition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 22 33\n```\n\n\n:::\n\n```{.r .cell-code}\na * 10 # Scalar multiplication is applied to each element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30\n```\n\n\n:::\n:::\n\n### Subsetting Vectors\n\nYou can select elements from a vector using their index inside square brackets `[]`. R uses 1-based indexing.\n\n::: {.cell}\n\n```{.r .cell-code}\ncharacter_vector[2] # Select the second element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"banana\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnumeric_vector[c(1, 3)] # Select the first and third elements\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.5 15.0\n```\n\n\n:::\n\n```{.r .cell-code}\nnumeric_vector[numeric_vector > 10] # Select elements based on a logical condition\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.5 15.0\n```\n\n\n:::\n\n```{.r .cell-code}\n# You can also exclude elements using negative indices\nnumeric_vector[-2] # Exclude the second element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.5 15.0  4.8\n```\n\n\n:::\n:::\n\n\n\n\n### Append Vector\n\nYou can combine vectors by using the `c()` function.\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3)\ny = c(4, 5, 6)\nz = c(x, y)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5 6\n```\n\n\n:::\n:::\n\n### Remove Elements from a Vector\n\nNegative indexing removes elements at the specified positions.\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4, 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\nRemove the first element:\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4 5\n```\n\n\n:::\n:::\n\nRemove the last element:\n\n::: {.cell}\n\n```{.r .cell-code}\nx[-length(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\nRemove elements based on a vector of indices:\n\n::: {.cell}\n\n```{.r .cell-code}\nremove = c(2, 4)\nx[-remove]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5\n```\n\n\n:::\n:::\n\n### Sort Vector\n\n`sort()` arranges vector elements in ascending or descending order.\n\n::: {.cell}\n\n```{.r .cell-code}\na = c(2, 4, 6, 1, 4)\nsort(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 4 4 6\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(a, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 4 4 2 1\n```\n\n\n:::\n:::\n\n### Vector Length\n\n`length()` returns the number of elements in a vector.\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n### Vector Calculation\n\nMathematical functions can be applied to entire vectors.\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 4, 5)\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n### Select Vector Elements\n\n::: {.cell}\n\n```{.r .cell-code}\nx = c(1, 2, 3, 6, 9, 10)\n```\n:::\n\nSelect the first element:\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n\nSelect the last element:\n\n::: {.cell}\n\n```{.r .cell-code}\nx[length(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\nSelect a range of elements:\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n### Compare Two Vectors\n\n`setdiff(x, y)` finds elements that are in vector `x` but not in vector `y`.\n\n::: {.cell}\n\n```{.r .cell-code}\nxx = c(1, 2, 3, 4)\nyy = c(2, 4)\nsetdiff(xx, yy)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3\n```\n\n\n:::\n:::\n        \n\n### Converting Between Vector Types\n\n`as.*` functions are used to coerce vectors from one type to another.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"g\", \"b\")\ny = as.factor(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a g b\nLevels: a b g\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c('123', '44', '222')\ny = as.numeric(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123  44 222\n```\n\n\n:::\n:::\n\n\n\n\n\n# 2. Data Frames\n\nA data frame is a two-dimensional, **heterogeneous** data structure, similar to a spreadsheet or a SQL table. It is the most important data structure for data analysis in R.\n\n-   Each column is a vector.\n-   Each column can have a different data type.\n-   All columns must have the same length.\n\n## Creating Data Frames\n\nUse the `data.frame()` function or, preferably, the `tibble()` function from the `tidyverse`. Tibbles are a modern take on data frames that are more user-friendly: they don't change variable names or types, and they have a much nicer print method.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_df <- tibble(\n  id = 1:4,\n  name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\"),\n  score = c(95, 82, 78, 91),\n  is_student = c(TRUE, FALSE, TRUE, FALSE)\n)\n\nmy_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 4\n     id name    score is_student\n  <int> <chr>   <dbl> <lgl>     \n1     1 Alice      95 TRUE      \n2     2 Bob        82 FALSE     \n3     3 Charlie    78 TRUE      \n4     4 David      91 FALSE     \n```\n\n\n:::\n:::\n\n## Subsetting Data Frames\n\nYou can subset data frames in several ways:\n\n-   `$` or `[[ ]]` to select a single column by name. This returns the column as a vector.\n-   `[row, column]` to select specific rows and columns. The result is another data frame (or a vector if you select a single column).\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select the 'name' column (returns a vector)\nmy_df$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"   \"Bob\"     \"Charlie\" \"David\"  \n```\n\n\n:::\n\n```{.r .cell-code}\n# Select the first two rows and the 'name' and 'score' columns (returns a tibble)\nmy_df[1:2, c(\"name\", \"score\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 2\n  name  score\n  <chr> <dbl>\n1 Alice    95\n2 Bob      82\n```\n\n\n:::\n:::\n\nFor more complex subsetting, it is highly recommended to use the `dplyr` verbs `filter()` and `select()` (covered in a separate guide).\n\n\n## Data Frame to Matrix\n\nConverting a data frame to a matrix will coerce all elements to the most flexible data type (usually character).\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- as.matrix(my_df)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     id  name      score is_student\n[1,] \"1\" \"Alice\"   \"95\"  \"TRUE\"    \n[2,] \"2\" \"Bob\"     \"82\"  \"FALSE\"   \n[3,] \"3\" \"Charlie\" \"78\"  \"TRUE\"    \n[4,] \"4\" \"David\"   \"91\"  \"FALSE\"   \n```\n\n\n:::\n:::\n\n## Data Frame to Vector\n\nYou can extract a single column as a vector using `$` or `[[ ]]` notation.\n\n::: {.cell}\n\n```{.r .cell-code}\nvec = my_df[['name']]\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"   \"Bob\"     \"Charlie\" \"David\"  \n```\n\n\n:::\n:::\n\n\n\n# 3. Matrices\n\nA matrix is a two-dimensional, **homogeneous** data structure. All elements must be of the same type. It is most useful for mathematical and statistical operations, such as linear algebra.\n\n### Creating Matrices\n\nUse the `matrix()` function.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- matrix(\n    data = 1:12,      # The data to fill the matrix\n    nrow = 3,         # The number of rows\n    ncol = 4,         # The number of columns\n    byrow = TRUE      # Fill the matrix row by row (default is by column)\n)\n\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n```\n\n\n:::\n:::\n\n### Subsetting Matrices\n\nSubsetting is similar to data frames, using `[row, column]` notation.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[2, 3] # Element in the 2nd row, 3rd column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix[1, ] # The entire 1st row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_matrix[, 4] # The entire 4th column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  8 12\n```\n\n\n:::\n:::\n\n### Matrix Operations\n\nMatrices support matrix algebra operations, such as transposition (`t()`) and matrix multiplication (`%*%`).\n\n::: {.cell}\n\n```{.r .cell-code}\nt(my_matrix) # Transpose the matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n```\n\n\n:::\n:::\n\n# 4. Lists\n\nA list is a one-dimensional, **heterogeneous** data structure. Unlike vectors, lists can contain elements of different types and even different structures, including other lists, vectors, or data frames. This makes them very flexible, like a container for other objects.\n\n## Creating Lists\n\nUse the `list()` function. It's good practice to name the list elements.\n\n::: {.cell}\n\n```{.r .cell-code}\n# A list is often used to return multiple results from a function\nmy_model_output <- list(\n  name = \"Linear Model\",\n  coefficients = c(intercept = 2.5, slope = 0.8),\n  r_squared = 0.85,\n  data = head(mtcars)\n)\n\nmy_model_output\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$name\n[1] \"Linear Model\"\n\n$coefficients\nintercept     slope \n      2.5       0.8 \n\n$r_squared\n[1] 0.85\n\n$data\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n:::\n\n## Subsetting Lists\n\nSubsetting lists requires understanding the difference between `[` and `[[`:\n\n-   `[[index]]` or `[[name]]` extracts a **single element** from the list. The result will have the type of that element.\n-   `[index]` or `[name]` extracts a **sub-list**. The result is always another list, even if you only select one element.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract the 'coefficients' vector (result is a numeric vector)\nmy_model_output[[\"coefficients\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nintercept     slope \n      2.5       0.8 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract a sub-list containing only the 'coefficients' element (result is a list)\nmy_model_output[\"coefficients\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$coefficients\nintercept     slope \n      2.5       0.8 \n```\n\n\n:::\n\n```{.r .cell-code}\n# Use the $ operator as a convenient shortcut for [[name]]\nmy_model_output$r_squared\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.85\n```\n\n\n:::\n:::\n\n# 5. Arrays\n\nAn array is a multi-dimensional, **homogeneous** data structure. It can have two or more dimensions. A 2D array is essentially a matrix. Arrays are useful for storing data that has more than two dimensions, such as image data (height, width, color channels) or time series data for multiple locations.\n\n## Creating Arrays\n\nUse the `array()` function, specifying the data and the dimensions.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a 3D array (2 rows, 3 columns, 2 layers)\nmy_array <- array(\n  data = 1:12, \n  dim = c(2, 3, 2)\n)\n\nmy_array\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n```\n\n\n:::\n:::\n\n## Subsetting Arrays\n\nElements are accessed using `[row, column, dimension]` notation.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Element in the 1st row, 2nd column of the 2nd layer\nmy_array[1, 2, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9\n```\n\n\n:::\n\n```{.r .cell-code}\n# The entire first matrix (1st layer)\nmy_array[, , 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n# 6. Inspecting Data Structures\n\nUnderstanding the structure of your data is a critical first step in any analysis. R provides several useful functions for this.\n\n-   `str()`: The most useful function. Provides a compact, human-readable summary of any R object.\n-   `class()`: Returns the high-level class of an object.\n-   `typeof()`: Returns the internal storage type.\n-   `length()`: Returns the number of elements in a vector or list.\n-   `dim()`: Returns the dimensions (e.g., rows and columns) of a data frame, matrix, or array.\n-   `names()` or `colnames()`: Returns the names of elements or columns.\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [4 Ã— 4] (S3: tbl_df/tbl/data.frame)\n $ id        : int [1:4] 1 2 3 4\n $ name      : chr [1:4] \"Alice\" \"Bob\" \"Charlie\" \"David\"\n $ score     : num [1:4] 95 82 78 91\n $ is_student: logi [1:4] TRUE FALSE TRUE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_model_output)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 4\n $ name        : chr \"Linear Model\"\n $ coefficients: Named num [1:2] 2.5 0.8\n  ..- attr(*, \"names\")= chr [1:2] \"intercept\" \"slope\"\n $ r_squared   : num 0.85\n $ data        :'data.frame':\t6 obs. of  11 variables:\n  ..$ mpg : num [1:6] 21 21 22.8 21.4 18.7 18.1\n  ..$ cyl : num [1:6] 6 6 4 6 8 6\n  ..$ disp: num [1:6] 160 160 108 258 360 225\n  ..$ hp  : num [1:6] 110 110 93 110 175 105\n  ..$ drat: num [1:6] 3.9 3.9 3.85 3.08 3.15 2.76\n  ..$ wt  : num [1:6] 2.62 2.88 2.32 3.21 3.44 ...\n  ..$ qsec: num [1:6] 16.5 17 18.6 19.4 17 ...\n  ..$ vs  : num [1:6] 0 0 1 1 0 1\n  ..$ am  : num [1:6] 1 1 1 0 0 0\n  ..$ gear: num [1:6] 4 4 4 3 3 3\n  ..$ carb: num [1:6] 4 4 1 1 2 1\n```\n\n\n:::\n:::\n\n# 7. Choosing the Right Data Structure\n\n| Use a...       | When you have...                                       | Example Use Case                                    |\n|----------------|--------------------------------------------------------|-----------------------------------------------------|\n| **Vector**     | A 1D sequence of the **same data type**.               | A single column of data, like ages or names.        |\n| **Data Frame** | A 2D table with columns of **different data types**.   | Your typical dataset for analysis.                  |\n| **Matrix**     | A 2D grid of the **same data type**.                   | A correlation matrix, an image grayscale matrix.    |\n| **List**       | A collection of **different types/structures**.        | To return multiple, varied objects from a function. |\n| **Array**      | A multi-dimensional grid of the **same data type**.    | 3D medical imaging data, climate data over time.    |\n\n# 8. Reference\n\n-   [GeeksforGeeks: Data Structures in R](https://www.geeksforgeeks.org/data-structures-in-r-programming/)\n-   [Advanced R by Hadley Wickham](https://adv-r.hadley.nz/vectors-chap.html)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}